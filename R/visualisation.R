#' Create a Circos visualisation
#'
#' @param sv_data somatic variants (SV) source data file. Format of the data should be:
#' \itemize{
#' \item `Chr.x`, start breakpoint chromosome,
#' \item `Cluster.x`, start breakpoint cluster (generated by `cluster_data` function),
#' \item `Position.x`, start breakpoint position,
#' \item `Chr.y`, end breakpoint chromosome,
#' \item `Cluster.y`, end breakpoint cluster (generated by `cluster_data` function),
#' \item `Position.y`, end breakpoint position,
#' \item `Class.x`, start breakpoint class (intergenic, intronic, exonic,...),
#' \item `Gene.x`, start breakpoint gene,
#' \item `Encode.x`, start breakpoint encode (Promotor, Enhancer, Heterochrom,...),
#' \item `Class.y`, end breakpoint class (intergenic, intronic, exonic,...),
#' \item `Gene.y`, end breakpoint gene,
#' \item `Encode.y`, end breakpoint encode (Promotor, Enhancer, Heterochrom,...),
#'
#' }
#' @param cnv_data An optional data source containing CNV information. Used to create a separate CNV track.
#' This should follow the required format (see `preprocessRawNexusFile` function).
#' @param chromosome_selection an optional vector containing a selection of chromosomes to be included in the visualisation.
#' @param path an optional vector containing specific breakpoint which belong to a path. If this is not NULL, the default visualisation changes -
#' all translocation link apart from the ones connecting breakpoints from the `path` attribute are gray, the path is shown in red.
#' @param sv_focus the subset of translocations to focus on: {`"itx"`, `"ctx"`, `"all"`}.
#' @param cnv_track_style the type of CNV track visualisation: `cnv_track_style = "full"` is default and will display the CNV baseline event (Allelic imbalance, shown in black).
#' Use `cnv_track_style = "trim"` to not include this baseline and only show Copy number gains and losses (red and blue segments).
#' @param link_color_cluster specifies which translocation end (translocation origin or translocation target) defines the color of the links.
#' @export
#'
visualiseCircos <- function(sv_data, cnv_data = NULL, chromosome_selection = NULL, path = NULL, sv_focus="all", cnv_track_style="full", link_color_cluster = "x"){

  #create a color palette used for cluster assignment
  distinctColorPalette <- function(n) {
    rainbow(n, s = 1, v = 1, start = 0, end = 1)
  }
  n <- max(sv_data$Cluster.x, sv_data$Cluster.y)
  color_vector <- stats::setNames(distinctColorPalette(n), c(1:n))

  #define colors for the CNV track
  if (cnv_track_style == "full"){
    cnv_colors=c("blue", "blue","black", "red", "red")

  }
  else if (cnv_track_style == "trim"){
    cnv_colors=c("blue", "blue", "red", "red")
  }
  else{
    stop("Invalid cnv_track_style option")
  }

  #filter SV data based on focus parameter
  if (sv_focus == "itx") {
    soma <- dplyr::filter(sv_data, Chr.x == Chr.y)

  }
  else if(sv_focus == "ctx"){
    soma <- dplyr::filter(sv_data, Chr.x != Chr.y)

  }
  else if (sv_focus == "all"){
    soma <- sv_data
  }
  else{
    stop("Incorrect SV focus value")
  }

  #filter SV data based on chromosome selection
  if (!is.null(chromosome_selection)) {
    soma <- dplyr::filter(soma, Chr.x %in% chromosome_selection & Chr.y %in% chromosome_selection)
  }

  # create Circos
  if(!is.null(chromosome_selection))
    circlize::circos.initializeWithIdeogram(chromosome.index = paste0("chr", chromosome_selection))
  else
    circlize::circos.initializeWithIdeogram()
  # if specified, use CNV data for its own track
  if(!is.null(cnv_data)){

    if(!is.null(chromosome_selection)){
      cnv_data <- dplyr::filter(cnv_data, chromosome %in% paste0("chr", chromosome_selection))
    }

    if(cnv_track_style == "trim"){
      cnv_data <- dplyr::filter(cnv_data, event != 2)
    }
    cnv_data <- as.data.frame(lapply(cnv_data, unlist))
    cnv_list <- split(cnv_data, cnv_data$event)

    circlize::circos.genomicTrack(cnv_list,track.height = 0.05, bg.lty = 0, stack = TRUE, panel.fun = function(region, value, ...) {
      i = circlize::getI(...)
      circlize::circos.genomicLines(region, value, col = cnv_colors[i], lwd = 1.5,...)
    })
  }

  if(!is.null(path)){
    for (i in 1:nrow(soma)) {
      skip_to_next <- FALSE
      tryCatch(
        expr = {
          circlize::circos.link(
            paste0("chr", soma$Chr.x[i]),
            soma$Position.x[i],
            paste0("chr", soma$Chr.y[i]),
            soma$Position.y[i],
            col = "#CCCCCC4D"
          )
        },
        error = function(e){
          skip_to_next <<- TRUE
        }
      )

      if(skip_to_next) { next }
    }

    for (i in seq(1, length(path), by = 2)) {
      start_breakpoint_id <- path[[i]]
      end_breakpoint_id <- path[[i + 1]]
      start_split <- strsplit(start_breakpoint_id, "_")[[1]]
      end_split <- strsplit(end_breakpoint_id, "_")[[1]]
      skip_to_next <- FALSE
      tryCatch(
        expr = {
          circlize::circos.link(
            paste0("chr", start_split[1]),
            as.integer(start_split[3]),
            paste0("chr", end_split[1]),
            as.integer(end_split[3]),
            col = 'red'
          )
        },
        error = function(e){
          skip_to_next <<- TRUE
        }
      )

      if(skip_to_next) { next }
    }
  }
  else{

    if(link_color_cluster == "x"){
      # add links to represent translocations
      for (i in 1:nrow(soma)) {
        circlize::circos.link(
          paste0("chr", soma$Chr.x[i]),
          soma$Position.x[i],
          paste0("chr", soma$Chr.y[i]),
          soma$Position.y[i],
          col = color_vector[soma$Cluster.x[i]]
        )
      }
    }
    else if(link_color_cluster == "y"){
      # add links to represent translocations
      for (i in 1:nrow(soma)) {
        circlize::circos.link(
          paste0("chr", soma$Chr.x[i]),
          soma$Position.x[i],
          paste0("chr", soma$Chr.y[i]),
          soma$Position.y[i],
          col = color_vector[soma$Cluster.y[i]]
        )
      }
    } else{
      stop("Incorrect link_color_cluster choice: select either `x` or `y`!")
    }
  }
}
